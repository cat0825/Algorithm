# 数组

## 二分查找

#### 思路

- 该数组必须有序

- 每次查找会缩小一半的范围

- 左值初始为0,右值为数组的大小-1

- 只要左值小于等于右值就一直进行循环比较 

### 代码区

```c++
#include"iostream"
#include"vector"
using namespace std;
int Search(vector<int>&v,int target){
    int left=0;
    int right=v.size()-1;
    int mid=(lefy+right)\2;
    while(left<=right){
        if(v[mid]==target){
            return mid;
        }else if(v[mid]<target){
            right=mid-1;
        }else{
            left=mid+1;
        }
    }
    return -1;
}
```

## 移除元素

### 暴力解法思路

- 两层嵌套的for循环分别进行遍历和覆盖操作 时间复杂度为o(n*2)
- 注意i--, 无法判断i++是否为target元素,要在i位置重新开始遍历\
- ![27.移除元素-暴力解法](https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95.gif)

#### 代码区(明天手写)

```c++
#include"iostream"
#include"vector"
using namespace std;
int demo(vetctor<int> &v,int target){
    for(int i=0;i<v.size();i++){
        if(v[i]==target){
            for(int j=i;j<v.size();j++){
                v[j]=v[j+1];
            }
            i--; 
            size--;
        } 
    }
    return size;
}
```

### 双指针法

- 快指针目的是查找非target值,慢指针的目的是记录数组的索引位置
- 时间复杂度为o(n)

#### 代码区

```c++
#include"iostream"
#include"vector"
using namespace std;
int demo2(vetctor<int> &v,int target){
    int size=v.size();
    int fast=0;
 	int slow=0;
    for(fast=0;fast<size;fast++){
        if(v[fast]!=target){
            v[slow]=v[fast];
            slow++;
        }
    }
    return slow;
}
```

## 有序数组的平方

### 暴力解法思路

- 每个元素先平方,在进行快排
- 时间复杂度为o(nlogn)

#### 代码区

```c++
vector<int> demo1(vector<int> &v)
{ // 暴力解法 先平方再快排
	for(int i=0;i<(int)v.size();i++){
        v[i]=v[i]*v[i];
    }
    sort(v.begin(),v.end());
    return v;
}
```

### 双指针法

- 两个指针向中间靠拢,再进行比较大小
- 小指针++ 大指针--
- 重要的是,从新建数组的末尾开始插入数值(升序排列),每插入一个元素 k-- ,(k为新建数组的最大索引)
- 时间复杂度为o(n)
- ![img](https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif)

#### 代码区

```c++
vector<int> demo2(vector<int>&v){  //双指针法
    vector<int>result(v.size(),0);
	int left=0;
    int size=v.size()-1;
    int right=size-1;
    int k=size-1;
    for(left=0,right=size-1;left<=right;){
        if(v[left]*v[left]>v[right]*v[right]){
            result[k]=v[left]*v[left];
            k--;
            left++;
        }else{
            result=v[right]*v[right];
            k--;
            right--;
        }
    }
    return result;
    
}
```

## 长度最小的子数组

### 暴力解法思路

- 两个for循环控制,第一个控制起始位置,第二个负责遍历
- 寻找最短的子序列返回

#### 代码

```c++
int demo1(vector<int> &v, int target)
{ // 暴力解法
	int result=INT32_MAX;
    int sum=0;
    int sublength=0;
    int size=v.size();
    for(int i=0;i<size;i++){
        sum=0;
        for(int j=i;j<size;j++){
            sum+=v[j];
            if(sum>=target){
                sublength=j-i+1;
                result=result < sublength ? result : sublength;
                break;
            }
        }
    }
    return result==INT32_MAX? 0:result;
}
```

### 滑动窗口

- 两个指针控制,只要寻找到>=target的值 就开始从起始位置缩短数组

![209.长度最小的子数组](https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

<img src="https://img-blog.csdnimg.cn/20210312160441942.png" alt="leetcode_209" style="zoom: 67%;" />

#### 代码

```c++
int demo2(vector<int>&v,int target){ //双指针解法
	int sum=0;
    int sunlength=0;
    int size=v.size();
    int result=INT32_MAX;
    int j=0;
    for(int i=0;i<size;i++){
        sum+=v[i];
        while(sum>=target){
            sublength=i-j+1;
            result=result<sublength:result:sublength;
            sum-=v[i];
            i++;
        }
    }
    return result==INT32_MAX? 0:result;
}

```

## 螺旋数组

### 思路

- 每条边坚持循环不变量的原则,每条边都是左闭右开
- 每条边一个循环进行赋值
- 注意理解offset(边界元素)和loop(循环次数)的意思
- 注意方法的返回值和创建二位的容器
- <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png" alt="img" style="zoom:33%;" />

#### 代码(明天写)

```c++
//螺旋数组
vector<vector<int>> demo(int n){
    vector<vector<int>> v(n,vector<int>(n,0));
    int loop=n/2;
    int startX=0;
    int startY=0;
    int count=1;
    int mid=n/2;
    int i,j;
    int offset=1;
    while(loop--){
        for(j=startX;j<n-offset;j++){
            v[i][j]=count;
            count++;
        }
        for(i=startY;i<n-offset;i++){
            v[i][j]=count;
            count++;
        }
        for(;j<n-offset;j--){
            v[i][j]=count;
            count++;
        }
        for(;i<n-offset;i--){
            v[i][j]=count;
            count++;
        }
    }
    if(n%2==1){
        v[mid][mid]=v;
    }
    return v;
}
```

# 链表

## 链表定义

### 单链表的定义

####  code

```c++
// 结构体定义
struct ListNode{
    int val;
    ListNode *next;
    ListNode(int x): val(x),next(NULL){}
};

// 初始化

ListNode *head =new ListNode(5);
```

## 移除链表元素

### 题意:删除链表中等于给定值 val 的所有节点。

### 一些思路

- 如何删除头节点:**将头节点的指针位置向后移动一位** +删除头节点占用的内存
- 或者设置一个新的虚拟的头节点

### 代码

```c++
```

